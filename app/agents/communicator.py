import logging
from datetime import datetime
from app.models.state import AgenticState, Lead
from app.utils import get_leads_by_status, update_performance_metrics
# This import connects to your email logic (whether it's Gmail, SendGrid, etc.)
from app.email_client import send_email

# Setup basic logging to see success/error messages in your terminal
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def process_lead_for_sending(lead: Lead) -> Lead:
    """
    Processes a single lead: sends the email via the email_client and updates the lead's state.
    """
    if not lead.communication_history:
        logging.warning(f"Lead {lead.lead_id} has no communication history to send. Skipping.")
        lead.status = "sending_failed"
        return lead

    # Get the latest communication generated by the Strategist
    last_communication = lead.communication_history[-1]
    
    # Extract the necessary details for the email
    recipient_email = lead.raw_data.get("email")
    subject = last_communication.get("subject", "Following Up")
    body = last_communication.get("message", "") # This is the personalized email body

    if not recipient_email:
        logging.error(f"Lead {lead.lead_id} has no email address. Cannot send.")
        lead.status = "sending_failed"
        return lead

    # --- This is the key part that calls your email client ---
    logging.info(f"ğŸ“¤ Attempting to send email to {recipient_email}...")
    
    # The send_email function from your email_client returns True on success, False on failure
    email_sent_successfully = send_email(
        to_email=recipient_email,
        subject=subject,
        html_content=body
    )
    
    if email_sent_successfully:
        # If sending succeeded, update the communication entry and the lead's primary status
        last_communication['status'] = 'sent'
        last_communication['sent_at'] = datetime.isoformat()
        lead.status = "outreach_sent"
    else:
        # If sending failed, update the status accordingly to prevent retries
        last_communication['status'] = 'failed'
        last_communication['failed_at'] = datetime.isoformat()
        lead.status = "sending_failed"
    
    return lead

def Communicator(state: AgenticState) -> AgenticState:
    """
    The Communicator agent "sends" emails that have been generated by the Strategist.
    It acts as a node in the LangGraph workflow.
    """
    # Find all leads that are in the "message_generated" state
    leads_to_contact = get_leads_by_status(state, "message_generated")

    if not leads_to_contact:
        print("No leads with generated messages to send.")
        return state
    
    print(f"Communicator agent processing {len(leads_to_contact)} leads for outreach...")

    sent_count = 0
    failed_count = 0
    for lead in leads_to_contact:
        try:
            processed_lead = process_lead_for_sending(lead)
            # Tally the results based on the final status
            if processed_lead.status == "outreach_sent":
                sent_count += 1
            else:
                failed_count += 1
        except Exception as e:
            logging.error(f"An unexpected error occurred while processing lead {lead.lead_id} for sending: {e}")
            lead.status = "sending_failed"
            failed_count += 1
    
    # Update the central performance metrics in the state
    if sent_count > 0:
        update_performance_metrics(state, "emails_sent", sent_count)

    print(f"\nCommunicator Run Complete ---")
    print(f"   - Emails Sent Successfully: {sent_count}")
    if failed_count > 0:
        print(f"   - Emails Failed to Send: {failed_count}")
    
    return state